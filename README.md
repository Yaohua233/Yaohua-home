- 基础语法
    - 基本数据类型
        - void 0字节
        - 指针 32位4字节，64位8字节
            - *访问指正所在内存地址中的值
            - &指向变量所在地址的值，一定不存在空引用，无法改变指向对象
        - 枚举类型 enmu
        - union 联合体 
        - const关键字，和*在一起的时候从右往左读
        - constexpr关键字
            - 编译时常量，优化性能很好
            - 不能包含函数调用或对象构造
            - 返回值不能是void类型
        - typedef关键字
        - volatile关键字，易变量，每次都需要从内存地址中读取这个数据
    - 运算符
        - 其他运算符
            - sizeof返回变量占位大小
            - condition？x:y
            - .   ->
            - &  *
        - 优先级从上到下递减
            - 作用域 :: 括号（）
            - 自增运算符 逻辑非
            - 算数运算符 左移右移运算符
            - 关系运算符
            - 位运算符
    - 逻辑控制语句
        - goto语句 会跳转到被标记的语句，不推荐使用
    - 函数
        - 形式参数类型
            - 传值
            - 传引用，地址是一样的，函数内操作等于对实际变量操作
            - 传指针，传地址进去，函数内操作影响实际变量的值
        - 一维数组 int a[]  二维数组int a[][10]
        - 默认参数int sum(int a,int b=20)
        - 函数修饰符extern，告诉编译器该函数或变量已在别处定义，不需要用include header.h
        - static 修饰的函数只本文件中调用
        - inline 编译器会将函数在调用点展开，直接将函数嵌入调用点，省去函数调用的开销
        - 函数重载，拥有相同的名称，但是函数参数列表和定义不相同
        - 可变参数
        (#include <iostream>)
        ()
        (// 可变参数模板函数)
        (template<typename... Args>)
        (void print(Args... args) {)
        ((std::cout << ... << args) << '\n'; // 使用折叠表达式来展开参数包)
        (})
        ()
        (int main() {)
        (print(1, 2.5, "Hello", 'c');)
        (return 0;)
        (})
        - 尾置返回类型
        - 函数指针，指向函数调用栈地址
    - 命名空间
        - namespace name{}括起来  ：：使用
        - 命名空间别名namespace na=longname
        - using
        - 匿名命名空间namespace{}
  - 面向对象
    - 类和对象
        - 类成员访问控制：public、protected、private
        - 成员默认访问权限是private
        - 友元函数、友元类可访问类的保护成员或私有成员，关键字friend，友元关系是单向的，尽量不使用友元
    - 类的构造和析构
        - 构造函数，未定义构造函数时，自动生成不带参数的默认版本
        (Student::Student(uint32_t id,uint32_t age))
        (:m_id(id),m_age(age)    //初始化列表)
        ({)
        (...)
        (})
            - 执行构造函数时先执行初始化列表，再执行函数体
            - 初始化的顺序是按照声明类型的顺序来初始化的
            - 构造函数同其他函数一样，允许被重载、委托
        - 析构函数
            - 在对象生存期结束时立即被调用，再释放对象所占空间
        - 关键字
            - 使用default关键字 要求生成默认构造函数 
            - 使用explicit关键字拒绝对象被隐式构造
            - 使用delete关键字删除部分构造函数，避免不符合预期的构造
            (Student(char id)=delete //表示不允许用传入单参数char类型进行构造)
        - 深浅构造
            - 浅拷贝，未定义复制构造，自动生成按照比特位进行复制的复制构造函数，内部成员变量指向同一块内存，数据内存均相同
            - 深拷贝，重新申请一块内存，数据相同，内存不同
        - 复制构造与移动构造
            - 用已存在的对象初始化同类新对象，形参为本类的对象const引用
            (Student(const Student& stud))
            - 可以用delete拒绝复制构造
            - 复制构造函数被调用的三种：直接定义、函数传参、函数返回值
            - 移动构造函数用于将某个临时对象（如函数返回值）的资源移交给另一个正在创建的新对象
            - 移动构造将销毁对象指向的内存移交给新对象接管，还是同一块内存，旧对象不再指向此内存
            (Test(Test&& obj): m_ptr(obj.m_ptr){obj.m_ptr=nullptr;})
    - 成员
        - 静态成员，可以被所有对象共享，但只能在类外定义和初始化；静态成员函数只能访问静态成员变量
        - const常量成员只能在类内初始化或初始化列表完成；const成员函数只能被const成员对象调用，只能访问不能修改
        - this指针，指向对象本身；隐含于类的每一个非静态成员函数参数列表中
        - 运算符重载
            - operator关键字后面连接运算符，如赋值：operator=
            - 重载new/delete可以定制对象的内存分配和释放过程
            - 重载函数运算符，可以使对象成为带有数据的函数，称之为闭包，伪装成函数指针，函数更加通用
            (bool operator()(int value){return value<threshold;})
        - 组合与前向声明
            - 类的成员可以是另一个类的对象
            - 组合类的构造函数不仅需要负责本类中基本类型成员数据初始化，也要对对象成员初始化
            - 前向声明，只能在声明之前被引用 ，不可以对该类对象操作
    - 类的继承
        - 继承与派生
            - 被继承的类叫做基类，新的类称为派生类
            - final关键字拒绝被继承
        - 类成员访问限制
            - public、public、private
            - 友元关系不能被继承
            - 显示指明基类的成员，加作用域限定符
        - 赋值兼容规则
            - 公有派生类对象可以当做基类的对象使用
            - 派生类可以初始化基类的引用，指针可以隐含转化为基类的指针
            - 通过基类对象名、指针只能访问基类继承的成员
        - 派生类的构造和析构
            - 默认情况需要定义自己的构造函数
            - using关键字继承基类构造函数，新增成员需要类内初始化
            (using Base::Base)
            - using关键字也能继承其他函数
            - 初始化顺序：基类构造函数、派生类初始化列表中其余项、构造函数体
            - 析构函数不能被继承
            - 派生类析构函数不需要显式调用基类析构函数
        - 多重继承与虚继承
            - 二义性、冗余问题
            - 虚基类消除二义性
            - 虚继承引入额外运行开销，避免虚继承，在虚继承中尽量不存在任何数据
    - 类的多态
        - 多态的实现：虚函数
            - 多态通过运行时动态绑定实现，将一个函数标识符和函数地址绑在一起
            - virtual关键字，动态地查找函数所在地址
            - 对需要多态特性的成员函数添加virtual关键字进行说明，虚函数经过派生类重写后实现多态
            - 虚函数不允许静态成员函数，不允许构造函数
            - override关键字标识，可加可不加；final关键字拒绝重写
            - 基类析构函数最好都声明为虚函数
        - 虚表与动态绑定
            - 虚表指针赋值在当前类的构造函数初始化列表执行之前，基类构造函数执行后
        - RTTI运行时类型识别
            - dynamic_cast可以在继承体系中完成类型双向转换，并运行时检查类型合法性
            - typeid获取实际类型
            - 没有虚函数存在时，dynamic_cast无法通过编译、typeid会给出静态绑定的结果
        - 抽象类
            - 纯虚函数，基类无需或无法给出定义的虚函数，具体实现留给派生类定义
            - 拥有纯虚函数的类称为抽象类，无法被实例化；析构函数不能为纯虚函数
    
