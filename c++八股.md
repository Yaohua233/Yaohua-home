## 指针和引用
```c++
int a=5;
int &b=a;  //初始化b的地址等于a的地址，b为int类型，&b为地址类型
int *p = &a; //&a等于a的地址，初始化时p为指针类型
cout<<*p<<endl; //p指向地址的值
cout<<&a<<endl; //a的地址
cout<<p<<endl; //p指向的地址 也是a的地址
cout<<&p<<endl; //p的地址，另一个地址
```
## const
方法 去掉对象名倒着读
+ 指针
  + 指向常量的指针 `const int* p`const在数据类型前面
  + 自身的常量的指针 `int* const p`const在数据类型后面，数据前面，
+ 引用
  + 指向常量的引用 `const int &q=a` 只有这一种，此时q的值不能改变，a的值可以改变
## 宏定义#define和const常量
## static
全局静态变量  作用域在声明文件之内
局部静态变量  作用域为函数或语句块
静态函数  仅在声明它的文件中可见
类的静态成员  无论创建多少个类的对象，**静态成员都只有一个副本**，与对象无关，所有对象共享，可以对对象进行计数  
  类名加范围解析运算符 :: 就可以访问
类的静态函数  同类的静态成员，不能访问类的this指针
## this指针
`this` 指针被隐含地声明为: ` ClassName *const this `  
ClassName 类的 `const` 成员函数中，`this` 指针的类型为：`const ClassName* const`  
## inline内联函数  
相当于把内联函数里面的内容写在调用内联函数处  
## 虚函数和纯虚函数
一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的  
c++运行时会查看指针指向的实际类型，再决定用哪个函数  
**纯虚函数最显著的特征是**：它们必须在继承类中重新声明函数，而且它们在抽象类中往往没有定义。
